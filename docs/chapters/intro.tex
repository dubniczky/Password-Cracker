\chapter{Bevezetés} % Introduction
\label{ch:intro}


% ------------------- Crypto basics
\section{A Kriptográfia Alapjai}

\subsection{Történet}
A fontos adatok titkosítása történelmünk során mindig fontos szerepet játszott akár háború közben a startégia terv biztonságos szállításához, vagy találmányok pontos specifikációjának a biztonságos tárolásához. Ennek köszönhetően a technológia fejlődésével a kriptográfiának mindig szorosan tartania kellett a lépést, hogy biztosítsa, hogy az adatokat nem csak most, hanem évek múlva sem lehet egyszerűen visszafejtenie illetékteleneknek \cite{katz2020introduction}.

A titkosítást és a visszafejtést legtöbbször papíron végezték, amely során egy előre meghatározott üzenetet a kriptográfus titkosított valamely eljárással, majd az eredményét leírta egy másik papírra. Ezek után a titkosított üzenet elküldésre került, amelyet optimális esetben kizárólag a céleszemély tudott visszafejteni. Ez azonban sok hibalehatőséget rejtett magában, hiszen amennyiben túl egyszerű a titkosítási módszer a feltörés is jelentősen könnyebb lett, azonban ha túl bonyolult akkor a kriptográfus hibáinak száma és egy üzenettel eltöltött ideje is megnőtt.

% Modern crypto
\subsection{Modern Kriptográfia}

Az első modern kriptográfus gépet két Dán üzletember fejlesztette ki 1915-ben, mely az Enigma nevet kapta \cite{ellis2005exploring}. A gép bemeneteként szolgált egy alap beállítás és az üzenetet, majd ebből visszaadott egy véletlenszerűenk tűnő karaktersorozatot. Megyegyező a beállításokkal és megegyező üzenettel a gép kimentene pontosan ugyan azt az eredményt adta minden alkalommal. Bárki a gép, az alap beállítás és a titkosított üzenet birtokában pontosan vissza tudta fejteni az eredi üzenetet. Azonban az alapbeállítás hiányában ez manuálisan közel lehetetlennek bizonyult.

A gép segíségével az összetett műveletek automatikusan megtörténtek és ezzel jelentősen csökkentették az emberhibából adódó problémákat, illetve sokszorosára gyorsították a folyamatot egy manuális számoláshoz képest.

Napjainkban ezen műveleteket már számítógépek végzik, amelyek az Enigma gép teljesítményének milliárdszorosát képesek elvégezni. Ennek köszönhetően a titkosítási módszerek teljesítményének is növekednie kellett.

% Methods
\subsection{Titkosítási módszerek}

Az általános titkosítási módszer úgynevezett szimmetrikus, vagy privát kulcsos titkosítás, amelyben egy kulcs és egy üzenet ismeretében egy titkosított üzenetet állítunk elő, amelyet a kulcs ismeretében lehet kizárólag visszafejteni. Fontos feltétel hogy a kulcs ismeretében gyorsan visszafejthető legyen, míg a kulcs ismerete nélkül szinte lehetetlen.

Ezzel szemben az asszimmetrikus módszer esetén két kulcsra van szükség. Egyre a titkosításhoz és egyre a feloldáshoz. Amennyiben az üzenetet az első kulccsal titkosítjuk, kizárólag a másodikkal lesz lehetőségünk visszafejteni azt. Ugyan ez működik az ellenkező irányban is. Ennek köszönhetően például az RSA algoritmus használatával egy publikus kulcsot bárhol tárolhatunk az interneten és amennyiben valaki üzenetet szeretne küldeni nekünk, titkosítja az üzenetét a publikus kulcsunkkal, majd elküldi nekünk és kizárólag mi tudjuk feloldani az üzenetet a privát kulccsal.

% Conclusion
\subsection{Konklúzió}

A kriptográfia egy komoly befolyással járó ágazat volt a történelmünk során, ugyanis esetenként akár országok jövője múlhatott azon hogy a titkos információkat biztonságosan tudják szállítani.
Az eddigiekben olyan titkosításról volt szó, amelyben valamilyen fél titkosít egy adatot és egy másik ezután vissza tudja nyerni pontosan az eredeti dokumentumot. Azonban erre nem minden esetben van szükség és bizonyos helyzetekben még hátrányos is. Ennek a megoldására alkalmazunk hash függvényeket.

% ------------------- Hash basics
\section{A Hash Alapjai}



% History
\subsection{Történet}

A szakdolgozatom fő inspirációjaként szolgált a számítógépes biztonságtechnika és a kódoptimalizálás témakörök vegyítése, amelyet a számítógéppel számolt hash feltörésére szolgáló programmal valósítottam meg.

A hash algoritmusokat egy egyszerűnek tűnő, de valójában összetett probléma megoldására alkották meg 1953-ban \cite{dang2015secure}. Tegyük fel, hogy van két nagy méretű dokumentum, amelyet meg akarunk vizsgálni, hogy megegyeznek-e. Mindezt egy olyan módszerrel amelynek nem kell végig vizsgálnia pontosan minden karaktert és elégséges a dokumentumok különbözőségének igazolására. Természetesen ezt teljes biztossággal kizárólag a pontos átvizsgálással lehet megtenni, azonban kialakíthatunk olyan módszereket ahol egyezés esetén annak az esélye hogy a dokumentumok nem egyeznek elenyésző. Sok egyéb tudományágban hagyatkozunk nem teljesen biztos, de valószínűségéből adódóan konklúzívnak vett eljárásokon. Például DNS teszt. Erre az informatikában egyik megoldásként született a hash használata.


% Good function
\subsection{Kritériumok}
\label{sec:criteries}

Egy hash algoritmus bemenetnek kap valamilyen adatot. Ez az algoritmustól függően tetszőleges bináris adatfolyam lehet, majd kimenetként visszaad egy fix hosszúságú kulcsot amelynek meg kell felelnie az alábbi alapszabályoknak \cite{preneel1993analysis}:

\begin{enumerate}
  \item \textbf{Univerzális}, azaz bármekkora és akármilyen típusú adatfolyamra működik, feltéve hogy reprezentálható bináris formában,
  \item \textbf{Adatvesztő}, azaz minden bemenetre azonos hoszúságú kimenetet ad, ezáltal a dokumentum nem lesz visszaállítható,
  \item \textbf{Determinisztikus}, azaz két azonos bemenet ugyan azt a kimenetet eredményezi,
  \item \textbf{Egyirányú}, azaz gyorsan kiszámolható a hash minden input alapján, viszont a kimenet ismeretében nem állítható vissza belátható időn belül a kiindulási dokumentum,
  \item \textbf{Egyedi}, azaz elenyésző az esélye, hogy két különböző bemenet azonos kimenetet generál,
  \item \textbf{Instabil}, azaz egy kisebb módosításnak a bemeneten nagy változást kell hogy eredményezzen a kimeneten.
\end{enumerate}

Egy ilyen algoritmus használatával két dokumentum összehasonlítható úgy, hogy mindkettőn lefuttatjuk ugyan azt az algoritmust és amennyiben a kimenet különbözik, a bemeneti dokumentumok bizotsan nem egyeznek. Azonban amennyiben egyeznek a hash-ek, szinte biztosan a dokumentumok is.

% SHAü256
\section{Az SHA-256 algoritmus}

Az SHA-256 egy kriptografikus hash algoritmus amely az SHA-2 egyik alváltozata, melyet az Egyesült Államokbeli National Security Agency fejlesztett ki 2001-ben~\cite{gueron2011sha}. Az SHA-2 két fő változattal rendelkezik: SHA-256 és SHA-512, amelyek között a fő különbség a használt szavak vagy szegmnesek mérete. Míg az SHA-256 32 bites, addig az SHA-512 64 bites szavakat használ. Egyik algoritmus sem feltörhető egyenlőre, ennek ellenére manapság a nagyobb rendszerek jobban preferálják ezen agloritmusok utódait az új rendszerekben. Integritás vizsgálathoz és kereséshez egyiket sem alkalmazzák viszonylag magas számítási igényük miatt, jelszavak titkosítására biztonságos tároláshoz az SHA-256 egy elterjedt módszer.

Az SHA-2 elődjére, az SHA-1-re épül, amely pedig a MerkleDamgård struktúrára. Abból adódóan, hogy ezt a struktúrát már sikerült feltörni, ezáltal az SHA-1 algoritmust is, bizonyítottá vált hogy csak idő kérdése, mielőtt az SHA-2 is hasonló sorsra jut \cite{sha2017survey}.

A megfelelő algoritmus kiválasztásánál három fő tulajdonságot vettem figyelembe:

\begin{enumerate}
  \item \textbf{Kritériumok:} Az algoritmusnak meg kell felelnie a \ref{sec:criteries} bekezdésben foglalt hash algoritmusokra vonatkozó feltételeknek,
  \item \textbf{Relevancia:} Az algoritmusnak jelszótitkosítás tekintetében napjainkban gyakran használtnak, vagy az algoritmus korábbi használatából adódóan jelentős mennyiségű feltörhető adattal kell rendelkezni,
  \item \textbf{Gyorsíthatóság:} Az algoritmusnak látványosan gyorsíthatónak kell lennie VGA parallelizáció segítségével
\end{enumerate}


% Unique proof
\subsection{Egyediség bizonyítása}

Az általam választott SHA-256 algoritmus \cite{gueron2011sha} minden bemenetre egy 64 hexadecimális karakteres (256 bites) kimenetet képez, amely tartalmazza az Angol ábécé betűit a-tól f-ig, illetve számjegyeket 0-tól 9-ig, így karakterenként 16 különböző lehetőségel rendelkezik. Kis és nagybetű között nem tesz különbséget, azonban a sorrend számít. Ez
%
{\hfil $$ (6 + 10)^{64} > \num{1.15e77} $$ \par}

különböző kulcslehetőséget képez. Ez olyan hatalmas mennyiség, hogy ha a következő 1000 évben a földön jelenleg élő minden ember minden nap elkészítene 100 egyedi kulcsú dokumentumot, akkor az összes lehetséges kulcs nagyjából 
%
\begin{equation}
    (1000 * \num{7800000000} * 365 * 100) = \num{2.847e17}
\end{equation}
\begin{equation}
    \frac{\num{2.847e17}}{(6 + 10)^{64}} \approx \num{2.46e-60}
\end{equation}
\begin{equation}
     = 0.000000000000000000000000000000000000000000000000000000000246 \%
\end{equation}
%
-a készülne csak el. Emiatt kijelenthetjük, hogy hash egyezés esetén feltételezhetjük hogy a bemeneti dokumentumok is pontosan megegyeznek.


% Use cases
\subsection{Alkalmazások}

A hash bevezetése sok problémára ad gyors és kényelmes megoldást, amelyek közül felsorolok egy néhány példát:


\begin{itemize}
  \item \textbf{Számítógéphálózat} átvitel során az átvitt adatok megsérülhetnek, illetve támadók módosíthatják azokat. Ezért az üzenetek mellé társítunk egy hash-et is, amelyet a küldő létrehoz, a fogadó pedig ellenőriz. \cite{chen2017approach}.
  \item \textbf{Adatbázis}-ból történő lekérdezés során az adatok hash algoritmusok felhasználásával csoportosíthatóak a gyorsabb kezelés érdekében \cite{dungan2010classifying}.
  \item \textbf{Adattárolás} esetében a merevlemezen a fájlok elérési útja, illetve a neve hash-ként van tárolva a gyorsabb beazonosítás érdekében \cite{garfinkel2010using}.
  \item \textbf{C++ modellek} esetén a nyelv alapkönyvtárában számos tárolási eszköz használ hash funkciókat az adatok kategorizálására és egyediségének vizsgálatára (pl: std::unordered\_set, std::unordered\_map) \cite{guntheroth2016optimized}.
  \item \textbf{Tranzakciókezelés} esetén egy limitként szolgálhat egy blokk kiszámítása, amelynek meg kell felelnie valamilyen sémának. Bitcoin esetén például 8 darab hexadecimális nulla karakterrel kell kezdődnie, akkor adható hozzá a tranzakció a blokk lánchoz (blockchain) \cite{courtois2014optimizing}.
  \item \textbf{Tartalom optimalizáció} esetén ha több felhasználó feltölti ugyan azt a médiát (kép, videó, hang), akkor a hash alapján be tudjuk azonosítani hogy az adott fájl már más által is felkerült-e, ebben az esetben az új feltöltő az új fájl helyett a régire fog mutatni és a másolat törlésre kerül.
  \item \textbf{Titkosítás} és autentikáció, azaz biztonságos azonosítás során Erről részletesebben a \ref{sec:hash_security} részben. 
\end{itemize}



% ------------------- Hash in security
\section{A Hash a Biztonságtechnikában}
\label{sec:hash_security}

\subsection{A Hash}

A számítógépes biztonságtechnikában a hash elsősorban jelszavak kapcsán jelenik meg, amelyeket szerverekre történő távoli bejelentkezéshez használunk. A megadott jelszót a szervernek valamely formában tárolnia kell, hogy sikeresen el tudja végezni a felhasználó azonosítását, azonban amennyiben ez az eredeti kulcs szöveges formájában történne meg, esetleges behatolás esetén minden regisztrált felhasználó jelszava megszerezhetővé válna. Ez veszélyes következményekkel járhat, ugyanis sokan egy jelszót több szolgáltatásnál is újra felhasználnak. Ezek tárolására egy általános megoldás a jelszó hash-algoritmussal történő egyirányú titkosítása.


\subsection{A Salt}

Ez a megoldás azonban egy problémát még nem old meg. Abból adódóan, hogy legtöbben egyszerű jelszavakat használnak, sokaknak ezek egyezni fognak és ezáltal az adatbázisban tárolt hozzárendelt hash-ek is. Emiatt annak ellenére hogy nem tudjuk mi a pontos jelszó, elég egy felhasználó jelszavát visszafejteni és a kapott kulcs biztosan működni fog minden másik egyező hash esetén is.

Erre megoldásként használjuk az úgynevezett "salt"-ot. Amely egy rövid karaktersorozat amit a jelszó titkosításakor véletlenszerűen generálunk, majd a jelszó végéhez fűzünk. Ez a salt végül a kiszámolt hash mellé kerül. A jelszó ellenőrzésekor a kapott jelszó után fűzzük ismét a hash mellett talált salt-ot és így futtatjuk le rajta az algoritmust. Ezáltal az azonos jelszavak is különbözően jelennek meg az adatbázisban.

A visszafejtést tovább komplikálhatjuk azzal, hogy többször is lefuttatjuk az algoritmust. Először a kulcs és salt kombináción, majd az ebből kapott hash eredményen. Ezt akármeddig ismételhetjük, azonban lineárisan növekszik a művelet ideje.

\subsection{Memóriaigény}

Az új generációs hash algoritmusok egyik fő szempontja a VGA gyorsítás megakadályozása. Ezt általában nagy mennyiségű memóriaigénnyel érik el, amely egy általános processzor számára, amely egyenletesen éri el a teljes memóriatartományt (dual-channel esetén a felét) nem okoz jelentős lassulást, azonban egy VGA esetén azt jelenti, hogy a lényegesen gyorsabb regiszter memória helyett a globális memóriát szükséges használni. Ennek köszönhetően esetenként a VGA-val történő feltörés lassabbnak is bizonyulhat mint ami egy hasonló árú processzorral elérhető \cite{mei2016dissecting}. Ezen oknál fogva ezek az algoritmusok kizárásra kerültek.

Példa a memóriaigény különbségekre:
\begin{table}[h]
\centering
    \begin{tabular}{|l|l|l|}
        \hline
        Algoritmus & Memóriaigény képlete & Memóriaigény \\
        \hline
        SHA-256 & 2 * 256 = \SI{512}{\bit} = & \SI{64}{\byte} \\
        \hline
        Scrypt & $N * 2r * \SI{64}{\byte} \rightarrow \num{16384} * 2*8 * \SI{64}{\byte}$ = & \SI{16}{\mega\byte} \\ 
        \hline
    \end{tabular}
    \caption{SHA-256 És Scrypt algoritmusok memóriaigényének összehasonlítása. Scrypt esetén a példaként felhozott N és r értékek egy általános konfigurációt mutatnak.}
\end{table}

\section{Motiváció}

A szakdolgozatom célja egy program elkészítése, amelyik egy jelszó hash-et egy lehetséges jelszó lista felhasználásával megpróbál visszafejteni videókártyás többszálú megoldással, illetve ezen program optimalizálása jelentős teljesítmény javulás érdekében. A programnak nem célja egy potenciális biztonsági rés kihasználására eszközt biztosítani, mindössze az általam kedvelt biztonságtechnika és optimalizálás témakörök vegyítésére ad lehetőséget.

A program elkészítéséhez a nyílt forráskódú OpenCL környezetet fogom használni, ugyanis kellő mélyséhű hozzáférést biztosít a grafikus kártya beslő kernelének kódolásához illetve a processzorral való kommunikációjához. Emellett elég általános ahhoz, hogy használható legyen több videókrátya rendszeren is.

A program írása során az általam elkészített rendszer potenciális gyorsítási lehetőségeket fogom tesztelni és elemezni, ezeket a saját számítógépem teljesítménye alapján rangsorolni. Egy véletlen jelszó feltörésének komplexitása alapján.